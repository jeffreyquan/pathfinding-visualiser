{"version":3,"sources":["PathfindingVisualiser/Scoreboard/Scoreboard.module.css","algorithms/dijkstra.js","algorithms/astar.js","PathfindingVisualiser/Node/Node.jsx","PathfindingVisualiser/helpers.js","algorithms/generateMaze.js","PathfindingVisualiser/Scoreboard/Scoreboard.jsx","PathfindingVisualiser/PathfindingVisualiser.jsx","algorithms/utils.js","App.js","reportWebVitals.js","index.js","PathfindingVisualiser/Node/Node.module.css","PathfindingVisualiser/PathfindingVisualiser.module.css"],"names":["module","exports","sortNodesByDistance","unvisitedNodes","sort","nodeA","nodeB","distance","updateUnvisitedNeighbors","node","grid","allowDiagonals","unvisitedNeighbors","neighbors","col","row","push","length","filter","neighbor","isVisited","getUnvisitedNeighbors","previousNode","getAllNodes","nodes","SQUARE_ROOT_OF_TWO","Math","sqrt","removeNodeFromList","index","indexOf","splice","getNodeWithLowestScore","reduce","prev","curr","fScore","heuristic","currentNode","finishNode","dx","abs","dy","min","getNeighbors","isWall","Node","forwardRef","ref","isStart","isFinish","onMouseDown","onMouseEnter","onMouseUp","id","className","clsx","styles","nodeStart","nodeFinish","nodeWall","createGrid","startNode","noOfRows","noOfCols","currentRow","createNode","Infinity","gScore","toggleFinishNode","newGrid","slice","newNode","toggleStartNode","getNewGridWithWallToggled","setInitialNode","generateMaze","addOuterWalls","addInnerWalls","isHorizontal","minX","maxX","minY","maxY","y","floor","randomNumber","console","log","hole","i","addHorizontalWall","x","addVerticalWall","max","random","Scoreboard","numberVisited","numberShortestPath","scoreboard","START_NODE","FINISH_NODE","PathfindingVisualiser","useState","setGrid","setStartNode","setFinishNode","algorithm","setAlgorithm","nodesInShortestPathOrder","setNodesInShortestPathOrder","visitedNodesInOrder","setVisitedNodesInOrder","nodeRefs","useRef","current","map","rowIndex","_","colIndex","createRef","animateShortestPath","useCallback","setTimeout","classList","add","nodeStyles","nodeShortestPath","animate","nodeVisited","useEffect","disabledGrid","setDisabledGrid","mouseIsPressed","setMouseIsPressed","setAllowDiagonals","disabledDiagonals","setDisabledDiagonals","visualiseAlgorithm","openSet","tentative_gScore","includes","astar","closestNode","shift","dijkstra","unshift","getNodesInShortestPathOrder","isStartNode","isFinishNode","resetShortestPath","forEach","remove","resetVisitedNodes","resetPath","resetAlgorithm","reset","disableButton","Container","container","Row","FormGroup","Label","for","subheading","Input","type","name","value","onChange","e","target","check","disabled","checked","buttonGroup","Button","size","color","onClick","outline","nodeIndex","handleMouseDown","handleMouseEnter","App","href","rel","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.c8d74288.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"scoreboard\":\"Scoreboard_scoreboard__1lENP\"};","// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also make nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function dijkstra(grid, startNode, finishNode, allowDiagonals = false) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n  while (!!unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid, allowDiagonals);\n  }\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(node, grid, allowDiagonals) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid, allowDiagonals);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid, allowDiagonals) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n\n  if (allowDiagonals) {\n    // Diagonals\n    // Top-left\n    if (row > 0 && col > 0) neighbors.push(grid[row - 1][col - 1]);\n    // Bottom-left\n    if (row < grid.length - 1 && col > 0)\n      neighbors.push(grid[row + 1][col - 1]);\n    // Top-right\n    if (row > 0 && col < grid[0].length - 1)\n      neighbors.push(grid[row - 1][col + 1]);\n    // Bottom-right\n    if (row < grid.length - 1 && col < grid[0].length - 1)\n      neighbors.push(grid[row + 1][col + 1]);\n  }\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n","// https://en.wikipedia.org/wiki/A*_search_algorithm\n\nconst SQUARE_ROOT_OF_TWO = Math.sqrt(2);\n\nexport function astar(grid, startNode, finishNode, allowDiagonals = false) {\n  const visitedNodesInOrder = [];\n  const openSet = [];\n  startNode.gScore = 0;\n  startNode.fScore = heuristic(startNode, finishNode);\n  openSet.push(startNode);\n  while (!!openSet.length) {\n    const currentNode = getNodeWithLowestScore(openSet);\n    if (currentNode.isWall) continue;\n    if (currentNode.gScore === Infinity) return visitedNodesInOrder;\n    currentNode.isVisited = true;\n    visitedNodesInOrder.push(currentNode);\n\n    if (currentNode === finishNode) return visitedNodesInOrder;\n\n    removeNodeFromList(openSet, currentNode);\n\n    const neighbors = getNeighbors(currentNode, grid, allowDiagonals);\n\n    for (const neighbor of neighbors) {\n      const tentative_gScore =\n        currentNode.gScore + heuristic(currentNode, neighbor, allowDiagonals);\n      if (tentative_gScore < neighbor.gScore) {\n        neighbor.previousNode = currentNode;\n        neighbor.gScore = tentative_gScore;\n        neighbor.fScore =\n          neighbor.gScore + heuristic(neighbor, finishNode, allowDiagonals);\n\n        if (!openSet.includes(neighbor)) {\n          openSet.push(neighbor);\n        }\n      } else {\n        continue;\n      }\n    }\n  }\n\n  return visitedNodesInOrder;\n}\n\nfunction removeNodeFromList(nodes, node) {\n  const index = nodes.indexOf(node);\n  nodes.splice(index, 1);\n}\n\nfunction getNodeWithLowestScore(nodes) {\n  return nodes.reduce((prev, curr) =>\n    prev.fScore < curr.fScore ? prev : curr\n  );\n}\n\nfunction heuristic(currentNode, finishNode, allowDiagonals) {\n  // http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html#diagonal-distance\n  const dx = Math.abs(finishNode.col - currentNode.col);\n  const dy = Math.abs(finishNode.row - currentNode.row);\n  return allowDiagonals\n    ? dx + dy + (SQUARE_ROOT_OF_TWO - 2) * Math.min(dx, dy)\n    : dx + dy;\n}\n\nfunction getNeighbors(node, grid, allowDiagonals) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n\n  if (allowDiagonals) {\n    // Diagonals\n    // Top-left\n    if (row > 0 && col > 0) neighbors.push(grid[row - 1][col - 1]);\n    // Bottom-left\n    if (row < grid.length - 1 && col > 0)\n      neighbors.push(grid[row + 1][col - 1]);\n    // Top-right\n    if (row > 0 && col < grid[0].length - 1)\n      neighbors.push(grid[row - 1][col + 1]);\n    // Bottom-right\n    if (row < grid.length - 1 && col < grid[0].length - 1)\n      neighbors.push(grid[row + 1][col + 1]);\n  }\n\n  return neighbors.filter((neighbor) => !neighbor.isWall);\n}\n","import React, { forwardRef } from \"react\";\nimport clsx from \"clsx\";\nimport styles from \"./Node.module.css\";\n\nconst Node = forwardRef(\n  (\n    {\n      row,\n      col,\n      isStart,\n      isFinish,\n      isWall,\n      onMouseDown,\n      onMouseEnter,\n      onMouseUp,\n    },\n    ref\n  ) => {\n    return (\n      <div\n        ref={ref}\n        id={`node-${row}-${col}`}\n        className={clsx(styles.node, {\n          [styles.nodeStart]: isStart,\n          [styles.nodeFinish]: isFinish,\n          [styles.nodeWall]: isWall,\n        })}\n        onMouseDown={() => onMouseDown(row, col)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        onMouseUp={() => onMouseUp()}\n      ></div>\n    );\n  }\n);\n\nexport default Node;\n","export function createGrid(startNode, finishNode, noOfRows, noOfCols) {\n  const grid = [];\n\n  for (let row = 0; row < noOfRows; row++) {\n    const currentRow = [];\n    for (let col = 0; col < noOfCols; col++) {\n      if (row === startNode.row && col === startNode.col) {\n        currentRow.push(createNode(row, col, true, false));\n        continue;\n      }\n\n      if (row === finishNode.row && col === finishNode.col) {\n        currentRow.push(createNode(row, col, false, true));\n        continue;\n      }\n\n      currentRow.push(createNode(row, col));\n    }\n    grid.push(currentRow);\n  }\n\n  return grid;\n}\n\nexport function createNode(row, col, isStart = false, isFinish = false) {\n  return {\n    col,\n    row,\n    isStart,\n    isFinish,\n    distance: Infinity,\n    isVisited: false,\n    isWall: false,\n    previousNode: null,\n    fScore: Infinity,\n    gScore: Infinity,\n  };\n}\n\nexport function toggleFinishNode(grid, row, col, isFinish) {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isFinish,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n}\n\nexport function toggleStartNode(grid, row, col, isStart) {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isStart,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n}\n\nexport function getNewGridWithWallToggled(grid, row, col) {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isWall: !node.isWall,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n}\n\nexport function setInitialNode(node) {\n  const { row, col } = node;\n  return {\n    row,\n    col,\n  };\n}\n\nexport function resetAlgorithm(grid, startNode, finishNode) {\n  return grid.map((row, rowIndex) =>\n    row.map((node, colIndex) => {\n      if (node.isWall) {\n        const newNode = createNode(rowIndex, colIndex);\n        newNode.isWall = true;\n        return newNode;\n      }\n      const isStart = rowIndex === startNode.row && colIndex === startNode.col;\n      const isFinish =\n        rowIndex === finishNode.row && colIndex === finishNode.col;\n      return createNode(rowIndex, colIndex, isStart, isFinish);\n    })\n  );\n}\n","import { createGrid } from \"../PathfindingVisualiser/helpers\";\n\n// https://stackoverflow.com/questions/23530756/maze-recursive-division-algorithm-design/23530960#23530960\n\nexport function generateMaze(startNode, finishNode, noOfRows, noOfCols) {\n  const grid = createGrid(startNode, finishNode, noOfRows, noOfCols);\n  addOuterWalls(grid, startNode, finishNode);\n  addInnerWalls(grid, true, 1, noOfRows - 2, 1, noOfCols - 2);\n  return grid;\n}\n\nfunction addOuterWalls(grid, startNode, finishNode) {\n  for (let row = 0; row < grid.length; row++) {\n    for (let col = 0; col < grid[0].length; col++) {\n      if (\n        row === 0 ||\n        row === grid.length - 1 ||\n        col === 0 ||\n        col === grid[0].length - 1\n      ) {\n        grid[row][col].isWall = true;\n      }\n    }\n  }\n\n  grid[startNode.row][startNode.col].isWall = false;\n  grid[finishNode.row][finishNode.col].isWall = false;\n}\n\nfunction addInnerWalls(grid, isHorizontal, minX, maxX, minY, maxY) {\n  if (isHorizontal) {\n    if (maxX - minX < 2) {\n      return;\n    }\n\n    const y = Math.floor(randomNumber(minY, maxY) / 2) * 2;\n    addHorizontalWall(grid, minX, maxX, y);\n\n    addInnerWalls(grid, !isHorizontal, minX, maxX, minY, y - 1);\n    addInnerWalls(grid, !isHorizontal, minX, maxX, y + 1, maxY);\n  } else {\n    if (maxY - minY < 2) {\n      return;\n    }\n\n    const x = Math.floor(randomNumber(minX, maxX) / 2) * 2;\n    addVerticalWall(grid, minY, maxY, x);\n\n    addInnerWalls(grid, !isHorizontal, minX, x - 1, minY, maxY);\n    addInnerWalls(grid, !isHorizontal, x + 1, maxX, minY, maxY);\n  }\n}\n\nfunction addHorizontalWall(grid, minX, maxX, y) {\n  console.log({ y });\n  const hole = Math.floor(randomNumber(minX, maxX) / 2) * 2 + 1;\n\n  for (let i = minX; i <= maxX; i++) {\n    if (!grid[y][i].isStart && !grid[y][i].isFinish) {\n      grid[y][i].isWall = true;\n    }\n  }\n\n  if (y !== 0 && y !== grid.length - 1) grid[y][hole].isWall = false;\n}\n\nfunction addVerticalWall(grid, minY, maxY, x) {\n  console.log({ x });\n  const hole = Math.floor(randomNumber(minY, maxY) / 2) * 2 + 1;\n\n  for (let i = minY; i <= maxY; i++) {\n    if (!grid[i][x].isStart && !grid[i][x].isFinish) {\n      grid[i][x].isWall = true;\n    }\n  }\n\n  if (x !== 0 && x !== grid[0].length - 1) grid[hole][x].isWall = false;\n}\n\nfunction randomNumber(min, max) {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n","import React from \"react\";\nimport styles from \"./Scoreboard.module.css\";\n\nexport default function Scoreboard({ numberVisited, numberShortestPath }) {\n  return (\n    <div className={styles.scoreboard}>\n      <div>Cells visited: {numberVisited}</div>\n      <div>Cells on shortest path: {numberShortestPath}</div>\n    </div>\n  );\n}\n","import React, {\n  createRef,\n  useCallback,\n  useEffect,\n  useRef,\n  useState,\n} from \"react\";\nimport { Button, Container, FormGroup, Input, Label, Row } from \"reactstrap\";\nimport { dijkstra } from \"../algorithms/dijkstra\";\nimport { astar } from \"../algorithms/astar\";\nimport { getNodesInShortestPathOrder } from \"../algorithms/utils\";\nimport Node from \"./Node\";\nimport styles from \"./PathfindingVisualiser.module.css\";\nimport nodeStyles from \"./Node/Node.module.css\";\nimport {\n  createGrid,\n  getNewGridWithWallToggled,\n  resetAlgorithm,\n  setInitialNode,\n  toggleFinishNode,\n  toggleStartNode,\n} from \"./helpers\";\nimport { generateMaze } from \"../algorithms/generateMaze\";\nimport Scoreboard from \"./Scoreboard\";\n\n// Initial Grid Constants\nconst NO_OF_ROWS = 21;\nconst NO_OF_COLS = 21;\nconst START_NODE = {\n  row: 10,\n  col: 5,\n};\nconst FINISH_NODE = {\n  row: 10,\n  col: 15,\n};\n\nexport default function PathfindingVisualiser() {\n  const [grid, setGrid] = useState(() =>\n    createGrid(START_NODE, FINISH_NODE, NO_OF_ROWS, NO_OF_COLS)\n  );\n\n  const [startNode, setStartNode] = useState(() => setInitialNode(START_NODE));\n\n  const [finishNode, setFinishNode] = useState(() =>\n    setInitialNode(FINISH_NODE)\n  );\n\n  const [algorithm, setAlgorithm] = useState(\"astar\");\n\n  const [nodesInShortestPathOrder, setNodesInShortestPathOrder] = useState([]);\n  const [visitedNodesInOrder, setVisitedNodesInOrder] = useState([]);\n\n  const nodeRefs = useRef([]);\n  nodeRefs.current = grid.map((row, rowIndex) => {\n    return row.map((_, colIndex) =>\n      !!nodeRefs.current.length\n        ? nodeRefs.current[rowIndex][colIndex]\n        : createRef()\n    );\n  });\n\n  const animateShortestPath = useCallback(() => {\n    if (nodesInShortestPathOrder.length === 1) return;\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const { row, col } = nodesInShortestPathOrder[i];\n        const nodeRef = nodeRefs.current[row][col];\n        nodeRef.current.classList.add(nodeStyles.nodeShortestPath);\n      }, 50 * i);\n    }\n  }, [nodesInShortestPathOrder]);\n\n  const animate = useCallback(() => {\n    for (let i = 0; i < visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length - 1) {\n        setTimeout(() => {\n          animateShortestPath(nodesInShortestPathOrder);\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const { row, col } = visitedNodesInOrder[i];\n        const nodeRef = nodeRefs.current[row][col];\n        nodeRef.current.classList.add(nodeStyles.nodeVisited);\n      }, 10 * i);\n    }\n  }, [animateShortestPath, nodesInShortestPathOrder, visitedNodesInOrder]);\n\n  useEffect(() => {\n    animate(visitedNodesInOrder, nodesInShortestPathOrder);\n  }, [animate, visitedNodesInOrder, nodesInShortestPathOrder]);\n\n  const [disabledGrid, setDisabledGrid] = useState(false);\n\n  const [mouseIsPressed, setMouseIsPressed] = useState(false);\n\n  const [allowDiagonals, setAllowDiagonals] = useState(false);\n\n  const [disabledDiagonals, setDisabledDiagonals] = useState(false);\n\n  useEffect(() => {\n    if (algorithm === \"dijkstra\") {\n      setAllowDiagonals(false);\n      setDisabledDiagonals(true);\n    }\n\n    if (algorithm === \"astar\") setDisabledDiagonals(false);\n  }, [algorithm]);\n\n  function visualiseAlgorithm() {\n    if (algorithm === \"astar\") {\n      setVisitedNodesInOrder(\n        astar(\n          grid,\n          grid[startNode.row][startNode.col],\n          grid[finishNode.row][finishNode.col],\n          allowDiagonals\n        )\n      );\n    } else if (algorithm === \"dijkstra\") {\n      setVisitedNodesInOrder(\n        dijkstra(\n          grid,\n          grid[startNode.row][startNode.col],\n          grid[finishNode.row][finishNode.col],\n          allowDiagonals\n        )\n      );\n    }\n    setNodesInShortestPathOrder(\n      getNodesInShortestPathOrder(grid[finishNode.row][finishNode.col])\n    );\n  }\n\n  function isStartNode(row, col) {\n    if (!startNode) return false;\n    return row === startNode.row && col === startNode.col;\n  }\n\n  function isFinishNode(row, col) {\n    if (!finishNode) return false;\n    return row === finishNode.row && col === finishNode.col;\n  }\n\n  // Mouse events on nodes\n  function handleMouseDown(row, col) {\n    if (disabledGrid) return;\n\n    if (isStartNode(row, col)) {\n      toggleStartNode(grid, row, col, false);\n      setStartNode(null);\n      return;\n    }\n\n    if (!startNode && !isFinishNode(row, col)) {\n      if (grid[row][col].isWall) return;\n      toggleStartNode(grid, row, col, true);\n      setStartNode(() => ({\n        row,\n        col,\n      }));\n      return;\n    }\n\n    if (isFinishNode(row, col)) {\n      toggleFinishNode(grid, row, col, false);\n      setFinishNode(null);\n      return;\n    }\n\n    if (!finishNode && !isStartNode(row, col)) {\n      if (grid[row][col].isWall) return;\n      toggleFinishNode(grid, row, col, true);\n      setFinishNode(() => ({\n        row,\n        col,\n      }));\n      return;\n    }\n\n    const newGrid = getNewGridWithWallToggled(grid, row, col);\n    setGrid(newGrid);\n    setMouseIsPressed(true);\n  }\n\n  function handleMouseEnter(row, col) {\n    if (!mouseIsPressed) return;\n    if (disabledGrid) return;\n    const newGrid = getNewGridWithWallToggled(grid, row, col);\n    setGrid(newGrid);\n  }\n\n  function handleMouseUp() {\n    if (disabledGrid) return;\n    setMouseIsPressed(false);\n  }\n\n  function resetShortestPath() {\n    nodesInShortestPathOrder.forEach((node) =>\n      nodeRefs.current[node.row][node.col].current.classList.remove(\n        nodeStyles.nodeShortestPath\n      )\n    );\n    setNodesInShortestPathOrder([]);\n  }\n\n  function resetVisitedNodes() {\n    visitedNodesInOrder.forEach((node) =>\n      nodeRefs.current[node.row][node.col].current.classList.remove(\n        nodeStyles.nodeVisited\n      )\n    );\n    setVisitedNodesInOrder([]);\n  }\n\n  function resetPath() {\n    resetShortestPath();\n    resetVisitedNodes();\n    setGrid(resetAlgorithm(grid, startNode, finishNode));\n    setDisabledGrid(false);\n  }\n\n  function reset() {\n    resetShortestPath();\n    resetVisitedNodes();\n    resetToInitialGrid();\n    setDisabledGrid(false);\n  }\n\n  function resetToInitialGrid() {\n    setGrid(createGrid(START_NODE, FINISH_NODE, NO_OF_ROWS, NO_OF_COLS));\n    setStartNode(setInitialNode(START_NODE));\n    setFinishNode(setInitialNode(FINISH_NODE));\n  }\n\n  function setMaze() {\n    resetShortestPath();\n    resetVisitedNodes();\n    setGrid(generateMaze(startNode, finishNode, NO_OF_ROWS, NO_OF_COLS));\n  }\n\n  function disableButton() {\n    return startNode === null || finishNode === null;\n  }\n\n  return (\n    <Container className={styles.container}>\n      <Row>\n        <FormGroup>\n          <Label for=\"algorithmSelect\">\n            <h2 className={styles.subheading}>Select Algorithm</h2>\n          </Label>\n          <Input\n            type=\"select\"\n            name=\"select\"\n            id=\"algorithmSelect\"\n            value={algorithm}\n            onChange={(e) => setAlgorithm(e.target.value)}\n          >\n            <option value=\"astar\">A*</option>\n            <option value=\"dijkstra\">Dijkstra</option>\n          </Input>\n        </FormGroup>\n      </Row>\n      <Row>\n        <FormGroup>\n          <Label check>\n            <Input\n              disabled={disabledDiagonals}\n              type=\"checkbox\"\n              aria-label=\"Checkbox for allowing diagonals in paths\"\n              value={allowDiagonals}\n              onChange={(e) => setAllowDiagonals(e.target.checked)}\n            />{\" \"}\n            Allow Diagonals\n          </Label>\n        </FormGroup>\n      </Row>\n      <Row>\n        <h2 className={styles.subheading}>Controls</h2>\n        <div className={styles.buttonGroup}>\n          <Button\n            size=\"sm\"\n            disabled={disabledGrid || disableButton()}\n            color=\"primary\"\n            onClick={() => {\n              resetPath();\n              setDisabledGrid(true);\n              visualiseAlgorithm();\n            }}\n          >\n            Visualise\n          </Button>\n          <Button\n            size=\"sm\"\n            disabled={disabledGrid || disableButton()}\n            outline\n            color=\"secondary\"\n            onClick={() => setMaze()}\n          >\n            Create Maze\n          </Button>\n          <Button\n            size=\"sm\"\n            disabled={disableButton()}\n            outline\n            color=\"danger\"\n            onClick={() => reset()}\n          >\n            Clear Board\n          </Button>\n          <Button\n            size=\"sm\"\n            disabled={disableButton()}\n            outline\n            color=\"warning\"\n            onClick={() => resetPath()}\n          >\n            Clear Path\n          </Button>\n        </div>\n      </Row>\n      <Row>\n        <Scoreboard\n          numberVisited={\n            visitedNodesInOrder.length > 0 ? visitedNodesInOrder.length : \"N/A\"\n          }\n          numberShortestPath={\n            nodesInShortestPathOrder.length > 0\n              ? nodesInShortestPathOrder.length\n              : \"N/A\"\n          }\n        />\n      </Row>\n      <div className={styles.grid}>\n        {grid.map((row, rowIndex) => (\n          <div key={rowIndex} className={styles.row}>\n            {row.map((node, nodeIndex) => {\n              const { row, col, isStart, isFinish, isWall } = node;\n              return (\n                <Node\n                  ref={nodeRefs.current[row][col]}\n                  key={nodeIndex}\n                  row={row}\n                  col={col}\n                  isStart={isStart}\n                  isFinish={isFinish}\n                  isWall={isWall}\n                  onMouseDown={() => handleMouseDown(row, col)}\n                  onMouseEnter={() => handleMouseEnter(row, col)}\n                  onMouseUp={() => handleMouseUp()}\n                />\n              );\n            })}\n          </div>\n        ))}\n      </div>\n    </Container>\n  );\n}\n","// Backtracks from the finishNode to find the shortest path.\nexport function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n","import \"./App.css\";\nimport PathfindingVisualiser from \"./PathfindingVisualiser\";\n\nfunction App() {\n  return (\n    <div className=\"root\">\n      <div className=\"title\">\n        <h1>Pathfinding Visualiser</h1>\n      </div>\n      <div className=\"link\">\n        <a\n          href=\"https://github.com/jeffreyquan/pathfinding-visualiser\"\n          target=\"_blank\"\n          rel=\"noreferrer noopener\"\n        >\n          Github\n        </a>\n      </div>\n      <PathfindingVisualiser />\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\nimport \"bootstrap/dist/css/bootstrap.min.css\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"node\":\"Node_node__21jjK\",\"nodeStart\":\"Node_nodeStart__27Ah3\",\"nodeFinish\":\"Node_nodeFinish__1ymnm\",\"nodeVisited\":\"Node_nodeVisited__3SCPR\",\"visitedAnimation\":\"Node_visitedAnimation__1Le_M\",\"nodeWall\":\"Node_nodeWall__1HVCx\",\"nodeShortestPath\":\"Node_nodeShortestPath__3aENZ\",\"shortestPath\":\"Node_shortestPath__2DXkP\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"container\":\"PathfindingVisualiser_container__3ImtK\",\"grid\":\"PathfindingVisualiser_grid__1-gAg\",\"row\":\"PathfindingVisualiser_row__2DrG5\",\"buttonGroup\":\"PathfindingVisualiser_buttonGroup__3mGMR\",\"subheading\":\"PathfindingVisualiser_subheading__17n8A\"};"],"sourceRoot":""}